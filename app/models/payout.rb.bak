# -*- encoding : utf-8 -*-

require 'core_extensions'
require 'loggable'

using CoreExtensions

class Payout < ActiveRecord::Base
  include Loggable

  # TODO: get them from config ?
  MINER_FEES = 0.005 # used in Payout.miner_fees_on
  MINER_MAX_FEES = 10**6 # Payout.miner_fees_on
  OUR_FEES = 0.02 # Payout.our_fees_on
  MINI_PAYOUT = 10**6 # BTC Satoshi

  # @@mutex = Mutex.new

  # # Je récupère
  # def self.run
  #   @@mutex.synchronize do
  #     accounts = Account.find_all( coin_id: Coin.find(code: 'BTC'), label: ["pool", "rent", "blocks", "balances"] )
  #     shares = Share.unpaid.accepted.all
  #     payout = Payout.new( accounts, shares )
  #     payout.send_it!
  #   end
  # end

  def Payout.miner_fees_on value
    fees = (value * MINER_FEES).floor
    fees = MINER_MAX_FEES if fees > MINER_MAX_FEES
    fees
  end

  def Payout.our_fees_on value
    (value * OUR_FEES).ceil
  end

  has_many :shares

  # attr_accessible :tx
  # attr_accessible :miner_fees, :our_fees, :users_amount
  attr_reader :users_sum_crumbs

  # Payout.new( accounts_ary, shares_ary )
  def initialize(*args, **kargs)
    objArg = OpenStruct.new(**kargs)
    @users_sum_crumbs = 0
    
    coin = objArg.delete(:coin) || Coin["BTC"]
    rpc = objArg.delete(:rpc) || coin.rpc

    # at least one Account in inputs, and outputs are all Shares.
    raise unless args.size == 2
    raise unless args.all? { |arg| arg.kind_of?(Array) }
    raise unless args[0].all? { |arg| arg.kind_of?( Account ) }
    raise unless args[1].all? { |arg| arg.kind_of?( Share ) }

    accounts, shares = *args.shift(2)

    super( *args, **objArg.to_h )

    self.tx = Transaction.new( coin: coin, rpc: rpc )

    # Retrieve unspent transactions and add them to inputs
    init_inputs( accounts )
    # Compute what go to us, miner and users.
    self.miner_fees, self.our_fees, self.users_amount = *compute_fees
    # 
    add_shares( shares )
  end

  def total_diff
    @total_diff ||= self.shares.map(&:difficulty).sum
  end

  def to_h
    {
      transaction: tx,
      miner_fees: miner_fees,
      our_fees: our_fees,
      users_amount: users_amount,
    }
  end

  def send_it!
    tx.send_it!
    log.info(
      "Payout sent for shares #{shares.first.id}..#{shares.last.id} :" +
      "- Our fees     : #{payout.our_fees / 10**-8} BTC ;" +
      "- Users amount : #{payout.users_amount / 10**-8} BTC ;" +
    )
    save!
    shares.each do |s| s.payout = self end
  end

  private
    def init_inputs( accounts )
      accounts.each do |account|
        account.listunspent.each do |tx|
          tx.add_input( tx.txid, tx.vout, tx.amount )
        end
      end
    end

    def compute_fees
      total_amount = tx.total_input
      miner_fees = Payout.miner_fees_on( total_amount )
      our_fees = Payout.our_fees_on( total_amount )
      users_amount = total_amount - miner_fees - our_fees
      if total_amount != our_fees + users_amount + miner_fees
        raise "diff in total sum : #{total_amount} != #{our_fees} + #{users_amount} + #{miner_fees}" end
      [miner_fees, our_fees, users_amount]
    end

    # Array of Share
    def add_shares( shares )
      return if shares.empty?
      
      # Add new shares to previous ones.
      self.shares += shares

      balances_in_sum, balances_out_sum = 0, 0

      res = self.shares.map { |s|
        diff_ratio = s.difficulty / total_diff # La difficulty est bien linéaire
        diff_sum = (users_amount * diff_ratio).floor
        bal_sum = s.user.balance
        if diff_sum + bal_sum >= MINI_PAYOUT
          tx.add_output( s.user, diff_sum + bal_sum )
          balances_out_sum += bal_sum
          s.user.balance = 0
        else
          balances_in_sum += diff_sum
          s.user.balance += diff_sum
        end
        [diff_ratio, diff_sum, s.user.balance - bal_sum, ]
      }

      @users_sum_crumbs = users_amount - res.inject(0) { |r, t| r += t[1] }
      log.warn "Too many crumbs on users_amount : #{@users_sum_crumbs} for #{self.shares.size} shares" if @users_sum_crumbs > self.shares.size
      users_ratio_sum = res.inject(0) { |r, t| r += t[0] }
      raise "difference in difficulty sum : #{users_ratio_sum} != 1" if users_ratio_sum != 1
      users_sum = res.inject(0) { |r, t| r += t[1] }
      raise "diff in user sum : #{users_sum} != #{users_sum + @users_sum_crumbs}" if users_amount != users_sum + @users_sum_crumbs

      # Add Fees
      self.users_amount -= @users_sum_crumbs
      self.our_fees += @users_sum_crumbs
      tx.add_output( Account.find_by(label: "fees"), self.our_fees )

      # Balance
      balances_account = Account.find_by(label: "balances")
      final_balance = balances_account.balance + balances_in_sum - balances_out_sum
      raise "final_balance too low : #{final_balance}" if final_balance < 0
      tx.add_output( balances_account, final_balance ) if final_balance != 0

      return {
        balance: {
          in: balances_in_sum,
          out: balances_in_sum
        },
        crumbs: @users_sum_crumbs,
        shares: res
      }
    end
end
